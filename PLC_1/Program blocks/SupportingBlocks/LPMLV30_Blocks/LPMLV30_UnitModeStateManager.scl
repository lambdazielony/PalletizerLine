FUNCTION_BLOCK "LPMLV30_UnitModeStateManager"
TITLE = LPMLV30_UnitModeStateManager
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : APC_ERLF
FAMILY : OMAC
//Support: tech.team.motioncontrol@siemens.com 
//Fax: +49 (0) 9131/98-1297
   VAR_INPUT 
      UnitMode : DInt := "LPMLV30_MODE_INVALID";   // Requested unit mode if enableBooleanInterface = FALSE
      UnitModeChangeRequest : Bool := false;   // TRUE: Request unit mode if enableBooleanInterface = FALSE
      CntrlCmd : DInt := "LPMLV30_CMD_UNDEFINED";   // Request control command if enableBooleanInterface = FALSE
      CmdChangeRequest : Bool := false;   // TRUE: Enable change into requested state if enableBooleanInterface = FALSE
      enableBooleanInterface : Bool := false;   // TRUE: Enable boolean interface
      ProductionModeRequest : Bool := false;   // TRUE: Request change to unit mode Production if enableBooleanInterface = TRUE
      MaintenanceModeRequest : Bool := false;   // TRUE: Request change to unit mode Maintenance if enableBooleanInterface = TRUE
      ManualModeRequest : Bool := false;   // TRUE: Request change to unit mode Manual if enableBooleanInterface = TRUE
      UserMode01Request : Bool := false;   // TRUE: Request change to user-defined unit mode 01 if enableBooleanInterface = TRUE
      UserMode02Request : Bool := false;   // TRUE: Request change to user-defined unit mode 02 if enableBooleanInterface = TRUE
      UserMode03Request : Bool := false;   // TRUE: Request change to user-defined unit mode 03 if enableBooleanInterface = TRUE
      UserMode04Request : Bool := false;   // TRUE: Request change to user-defined unit mode 04 if enableBooleanInterface = TRUE
      UserMode05Request : Bool := false;   // TRUE: Request change to user-defined unit mode 05 if enableBooleanInterface = TRUE
      UserMode06Request : Bool := false;   // TRUE: Request change to user-defined unit mode 06 if enableBooleanInterface = TRUE
      UserMode07Request : Bool := false;   // TRUE: Request change to user-defined unit mode 07 if enableBooleanInterface = TRUE
      UserMode08Request : Bool := false;   // TRUE: Request change to user-defined unit mode 08 if enableBooleanInterface = TRUE
      ResetCmdRequest : Bool := false;   // TRUE: Request control command Reset if enableBooleanInterface = TRUE
      StartCmdRequest : Bool := false;   // TRUE: Request control command Start if enableBooleanInterface = TRUE
      StopCmdRequest : Bool := false;   // TRUE: Request control command Stop if enableBooleanInterface = TRUE
      HoldCmdRequest : Bool := false;   // TRUE: Request control command Hold if enableBooleanInterface = TRUE
      UnholdCmdRequest : Bool := false;   // TRUE: Request control command Unhold if enableBooleanInterface = TRUE
      SuspendCmdRequest : Bool := false;   // TRUE: Request control command Suspend if enableBooleanInterface = TRUE
      UnsuspendCmdRequest : Bool := false;   // TRUE: Request control command Unsuspend if enableBooleanInterface = TRUE
      AbortCmdRequest : Bool := false;   // TRUE: Request control command Abort if enableBooleanInterface = TRUE
      ClearCmdRequest : Bool := false;   // TRUE: Request control command Clear if enableBooleanInterface = TRUE
      CompleteCmdRequest : Bool := false;   // TRUE: Request control command Complete if enableBooleanInterface = TRUE
      SC : Bool := false;   // State change from FALSE to TRUE (rising edge) triggers state complete signal
      configuration : "typeLPMLV30_Configuration" := ([12(false), 20(true)], [32(0)]);   // FB configuration
   END_VAR

   VAR_OUTPUT 
      UnitModeCurrent : DInt := "LPMLV30_MODE_MANUAL";   // Current unit mode
      UnitModeRequested : DInt := 0;   // Requested unit mode
      UnitModeChangeInProcess : Bool := false;   // Unit mode change in process
      StateCurrent : DInt := "LPMLV30_STATE_STOPPED";   // Current state
      StateRequested : DInt := 0;   // Requested state
      StateChangeInProcess : Bool := false;   // State change in process
      ProductionModeActive : Bool := false;   // TRUE: Unit mode Production is currently active
      MaintenanceModeActive : Bool := false;   // TRUE: Unit mode Maintenance is currently active
      ManualModeActive : Bool := false;   // TRUE: Unit mode Manual is currently active
      UserMode01Active : Bool := false;   // TRUE: User-defined unit mode 01 is currently active
      UserMode02Active : Bool := false;   // TRUE: User-defined unit mode 02 is currently active
      UserMode03Active : Bool := false;   // TRUE: User-defined unit mode 03 is currently active
      UserMode04Active : Bool := false;   // TRUE: User-defined unit mode 04 is currently active
      UserMode05Active : Bool := false;   // TRUE: User-defined unit mode 05 is currently active
      UserMode06Active : Bool := false;   // TRUE: User-defined unit mode 06 is currently active
      UserMode07Active : Bool := false;   // TRUE: User-defined unit mode 07 is currently active
      UserMode08Active : Bool := false;   // TRUE: User-defined unit mode 08 is currently active
      ClearingStateActive : Bool := false;   // TRUE: State Clearing is currently active
      StoppedStateActive : Bool := false;   // TRUE: State Stopped is currently active
      StartingStateActive : Bool := false;   // TRUE: State Starting is currently active
      IdleStateActive : Bool := false;   // TRUE: State Idle is currently active
      SuspendedStateActive : Bool := false;   // TRUE: State Suspended is currently active
      ExecuteStateActive : Bool := false;   // TRUE: State Execute is currently active
      StoppingStateActive : Bool := false;   // TRUE: State Stopping is currently active
      AbortingStateActive : Bool := false;   // TRUE: State Aborting is currently active
      AbortedStateActive : Bool := false;   // TRUE: State Aborted is currently active
      HoldingStateActive : Bool := false;   // TRUE: State Holding is currently active
      HeldStateActive : Bool := false;   // TRUE: State Held is currently active
      UnholdingStateActive : Bool := false;   // TRUE: State Unholding is currently active
      SuspendingStateActive : Bool := false;   // TRUE: State Suspending is currently active
      UnsuspendingStateActive : Bool := false;   // TRUE: State Unsuspending is currently active
      ResettingStateActive : Bool := false;   // TRUE: State Resetting is currently active
      CompletingStateActive : Bool := false;   // TRUE: State Completing is currently active
      CompleteStateActive : Bool := false;   // TRUE: State Complete is currently active
      StatesDisabled : DInt;   // Disabled states in current unit mode
      diagnostics : "typeLPMLV30_Diagnostics";   // Diagnostics information of FB
   END_VAR

   VAR 
      statConfiguration : "typeLPMLV30_Configuration" := ([12(false), 20(true)], [32(0)]);   // FB configuration
      statUnitModeChangeRequest : Bool := false;   // TRUE: Enable change into requested unit mode
      statCmdChangeRequest : Bool := false;   // TRUE: Enable change into requested state
      statFirstCycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // First cycle of run
      statSCOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;   // For edge detection
      statUnitMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_MODE_MANUAL";   // Current command mode
      statUnitModeOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_MODE_MANUAL";   // For edge detection
      statUnitModeCurrentInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_MODE_MANUAL";   // Current internal Mode
      statUnitModeCurrentInternalOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_MODE_INVALID";   // For edge detection
      statStateCurrentOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_STATE_STOPPED";   // For edge detection
      statStateInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_STATE_STOPPED";   // Current internal state
      statStateInternalOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_STATE_UNDEFINED";   // For edge detection
      statCntrlCmdOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := "LPMLV30_CMD_UNDEFINED";   // For edge detection
      statStatesInCurrentMode : Struct   // Copied from configuration
         clearing : Bool;
         stopped : Bool;
         starting : Bool;
         idle : Bool;
         suspended : Bool;
         execute : Bool;
         stopping : Bool;
         aborting : Bool;
         aborted : Bool;
         holding : Bool;
         held : Bool;
         unholding : Bool;
         suspending : Bool;
         unsuspending : Bool;
         resetting : Bool;
         completing : Bool;
         complete : Bool;
      END_STRUCT;
      statBooleanInterfaceModeOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // For edge detection
      statBooleanInterfaceCmdOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // For edge detection
      statCmdChangeRequestOld : Bool := false;   // For edge detection
      statUnitModeChangeRequestOld : Bool := false;   // For edge detection
   END_VAR

   VAR_TEMP 
      tempCntrlCmd : DInt;   // Temporary control command
      tempBooleanInterfaceMode : DWord;   // Status of boolean Mode inputs if  boolean interface is active
      tempBooleanInterfaceCmd : Word;   // Status of boolean Cmd inputs except abort and stop if  boolean interface is active
      tempSCInternal : Bool;   // Internal state complete
      tempRetVal : Int;   // Tag for system function
      tempDiagnosticsBufferIndex : Int;   // Index of actual diagnostics buffer entry
      tempDiagnosticsBufferIndexSC : Int;   // Index of actual diagnostics buffer entry for SC messages
      tempDiagnosticsBufferIndexCmd : Int;   // Index of actual diagnostics buffer entry for control command messages
   END_VAR

   VAR CONSTANT 
      MSG_NO_MESSAGE : Byte := 16#00;   // Initial value
      MSG_MODE_CHANGED_SUCCESSFULLY : Byte := 16#01;   // Unit mode changed successfully
      MSG_STATE_CHANGED_SUCCESSFULLY : Byte := 16#02;   // State changed successfully
      MSG_MODE_ALREADY_ACTIVE : Byte := 16#03;   // Requested unit mode already active
      MSG_MODE_NOT_DEFINED : Byte := 16#80;   // Unit mode not defined
      MSG_CMD_NOT_DEFINED : Byte := 16#81;   // Control command not defined
      MSG_REQ_MODE_NOT_CONFIGURED : Byte := 16#82;   // Requested unit mode not configured
      MSG_MODE_TRANSITION_NOT_ALLOWED : Byte := 16#83;   // Unit mode transition not allowed
      MSG_CMD_NOT_ALLOWED : Byte := 16#84;   // Control command in this state not allowed
      MSG_SC_NOT_ALLOWED : Byte := 16#85;   // SC in this state not allowed
      MSG_STATE_CONFIG_FORCED : Byte := 16#86;   // State configuration forced to OMAC standard (corrected configuration -> FB output StatesDisabled)
   END_VAR


BEGIN
	//============================================================================================================
	// SIEMENS AG
	// (c)Copyright 2015 All Rights Reserved
	//------------------------------------------------------------------------------------------------------------
	// Library: LPMLV30
	// Tested with: S7-1200 with FW version V4.1, S7-1500 with FW version V1.7
	// Engineering: TIA Portal V13 SP1
	// Restrictions: ---
	// Requirements: S7-1200 / S7-1500
	// Functionality: Management of unit modes and states according to ISA TR88.00.02 - June 4, 2014
	//------------------------------------------------------------------------------------------------------------
	// Change log table:
	// Version  Date        Expert in charge    Changes applied
	// 03.00.01 29.05.2015  RK                  First released version 
	//============================================================================================================
	// Function block: LPMLV30_UnitModeStateManager
	//============================================================================================================
	
	IF NOT #statCmdChangeRequest AND #statCmdChangeRequestOld THEN // Falling edge CmdChangeRequest
	  #statCntrlCmdOld := "LPMLV30_CMD_UNDEFINED";
	END_IF;
	#statCmdChangeRequestOld := #statCmdChangeRequest;
	
	IF NOT #statUnitModeChangeRequest AND #statUnitModeChangeRequestOld THEN // Falling edge UnitModeChangeRequest
	  #statUnitModeOld := "LPMLV30_MODE_INVALID";
	END_IF;
	#statUnitModeChangeRequestOld := #statUnitModeChangeRequest;
	
	#tempDiagnosticsBufferIndex    := #diagnostics.bufferIndex; // Work with temporary variable during block execution
	#tempDiagnosticsBufferIndexSC  := -1;
	#tempDiagnosticsBufferIndexCmd := -1;
	
	IF #statFirstCycle THEN // Initialize values in first cycle
	  #tempDiagnosticsBufferIndex := -1;
	
	  #statConfiguration := #configuration; // Copy configuration from input
	  #statConfiguration.disabledUnitModes["LPMLV30_MODE_MANUAL"] := FALSE; // Unit mode Manual is mandatory
	  
	  // Initialize unit mode
	  #statUnitMode                   := "LPMLV30_MODE_MANUAL";
	  #statUnitModeOld                := "LPMLV30_MODE_MANUAL";
	  #UnitModeCurrent                := "LPMLV30_MODE_MANUAL";
	  #statUnitModeCurrentInternal    := "LPMLV30_MODE_MANUAL";
	  #statUnitModeCurrentInternalOld := "LPMLV30_MODE_INVALID";
	  #statBooleanInterfaceModeOld    := 0;
	  
	  // Initialize state
	  #StateCurrent         := "LPMLV30_STATE_STOPPED";
	  #StateRequested       := "LPMLV30_STATE_STOPPED";
	  #statStateInternal    := "LPMLV30_STATE_STOPPED";
	  #statStateInternalOld := "LPMLV30_STATE_UNDEFINED";
	  #statStateCurrentOld  := "LPMLV30_STATE_STOPPED";
	  
	  // Initialize control command
	  #tempCntrlCmd               := "LPMLV30_CMD_UNDEFINED";
	  #statCntrlCmdOld            := "LPMLV30_CMD_UNDEFINED";
	  #statBooleanInterfaceCmdOld := 0;
	END_IF; // End: Initialize values in first cycle
	
	//--------------------------------------------------------------------------------------------------
	// Evaluation of input parameters -> UnitMode, CntrlCmd
	//--------------------------------------------------------------------------------------------------
	IF NOT #statFirstCycle THEN // As from second cycle
	  IF NOT #enableBooleanInterface THEN // Set unit mode and control command according to input parameters
	    #statUnitMode := #UnitMode;
	    #tempCntrlCmd := #CntrlCmd;
	    
	    // Set change requests from input
	    #statUnitModeChangeRequest := #UnitModeChangeRequest;
	    #statCmdChangeRequest      := #CmdChangeRequest;
	  ELSE // Read boolean interface inputs
	    #statUnitModeChangeRequest := TRUE; // Change request static TRUE
	    #statUnitMode              := "LPMLV30_MODE_INVALID";
	    #tempBooleanInterfaceMode  := 0;
	    
	    // Collect unit mode from boolean inputs
	    #tempBooleanInterfaceMode.%X1  := #ProductionModeRequest;
	    #tempBooleanInterfaceMode.%X2  := #MaintenanceModeRequest;
	    #tempBooleanInterfaceMode.%X3  := #ManualModeRequest;
	    #tempBooleanInterfaceMode.%X4  := #UserMode01Request;
	    #tempBooleanInterfaceMode.%X5  := #UserMode02Request;
	    #tempBooleanInterfaceMode.%X6  := #UserMode03Request;
	    #tempBooleanInterfaceMode.%X7  := #UserMode04Request;
	    #tempBooleanInterfaceMode.%X8  := #UserMode05Request;
	    #tempBooleanInterfaceMode.%X9  := #UserMode06Request;
	    #tempBooleanInterfaceMode.%X10 := #UserMode07Request;
	    #tempBooleanInterfaceMode.%X11 := #UserMode08Request;
	    // #tempBooleanInterfaceMode.%X12 := #UserMode09Request;
	    // #tempBooleanInterfaceMode.%X13 := #UserMode10Request;
	    // #tempBooleanInterfaceMode.%X14 := #UserMode11Request;
	    // #tempBooleanInterfaceMode.%X15 := #UserMode12Request;
	    // #tempBooleanInterfaceMode.%X16 := #UserMode13Request;
	    // #tempBooleanInterfaceMode.%X17 := #UserMode14Request;
	    // #tempBooleanInterfaceMode.%X18 := #UserMode15Request;
	    // #tempBooleanInterfaceMode.%X19 := #UserMode16Request;
	    // #tempBooleanInterfaceMode.%X20 := #UserMode17Request;
	    // #tempBooleanInterfaceMode.%X21 := #UserMode18Request;
	    // #tempBooleanInterfaceMode.%X22 := #UserMode19Request;
	    // #tempBooleanInterfaceMode.%X23 := #UserMode20Request;
	    // #tempBooleanInterfaceMode.%X24 := #UserMode21Request;
	    // #tempBooleanInterfaceMode.%X25 := #UserMode22Request;
	    // #tempBooleanInterfaceMode.%X26 := #UserMode23Request;
	    // #tempBooleanInterfaceMode.%X27 := #UserMode24Request;
	    // #tempBooleanInterfaceMode.%X28 := #UserMode25Request;
	    // #tempBooleanInterfaceMode.%X29 := #UserMode26Request;
	    // #tempBooleanInterfaceMode.%X30 := #UserMode27Request;
	    // #tempBooleanInterfaceMode.%X31 := #UserMode28Request;
	
	    // Selection indicator: Rising edge at input, Priority (in case of multiple selection): Manual, Maintenance, User Mode 01..28, Production
	    IF #tempBooleanInterfaceMode.%X3  AND NOT #statBooleanInterfaceModeOld.%X3  THEN
	      #statUnitMode := "LPMLV30_MODE_MANUAL";
	    ELSIF #tempBooleanInterfaceMode.%X2  AND NOT #statBooleanInterfaceModeOld.%X2  THEN
	      #statUnitMode := "LPMLV30_MODE_MAINTENANCE";
	    ELSIF #tempBooleanInterfaceMode.%X4  AND NOT #statBooleanInterfaceModeOld.%X4  THEN
	      #statUnitMode := "LPMLV30_MODE_USER_01";
	    ELSIF #tempBooleanInterfaceMode.%X5  AND NOT #statBooleanInterfaceModeOld.%X5  THEN
	      #statUnitMode := "LPMLV30_MODE_USER_02";
	    ELSIF #tempBooleanInterfaceMode.%X6  AND NOT #statBooleanInterfaceModeOld.%X6  THEN
	      #statUnitMode := "LPMLV30_MODE_USER_03";
	    ELSIF #tempBooleanInterfaceMode.%X7  AND NOT #statBooleanInterfaceModeOld.%X7  THEN
	      #statUnitMode := "LPMLV30_MODE_USER_04";
	    ELSIF #tempBooleanInterfaceMode.%X8  AND NOT #statBooleanInterfaceModeOld.%X8  THEN
	      #statUnitMode := "LPMLV30_MODE_USER_05";
	    ELSIF #tempBooleanInterfaceMode.%X9  AND NOT #statBooleanInterfaceModeOld.%X9  THEN
	      #statUnitMode := "LPMLV30_MODE_USER_06";
	    ELSIF #tempBooleanInterfaceMode.%X10 AND NOT #statBooleanInterfaceModeOld.%X10 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_07";
	    ELSIF #tempBooleanInterfaceMode.%X11 AND NOT #statBooleanInterfaceModeOld.%X11 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_08";
	    ELSIF #tempBooleanInterfaceMode.%X12 AND NOT #statBooleanInterfaceModeOld.%X12 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_09";
	    ELSIF #tempBooleanInterfaceMode.%X13 AND NOT #statBooleanInterfaceModeOld.%X13 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_10";
	    ELSIF #tempBooleanInterfaceMode.%X14 AND NOT #statBooleanInterfaceModeOld.%X14 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_11";
	    ELSIF #tempBooleanInterfaceMode.%X15 AND NOT #statBooleanInterfaceModeOld.%X15 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_12";
	    ELSIF #tempBooleanInterfaceMode.%X16 AND NOT #statBooleanInterfaceModeOld.%X16 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_13";
	    ELSIF #tempBooleanInterfaceMode.%X17 AND NOT #statBooleanInterfaceModeOld.%X17 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_14";
	    ELSIF #tempBooleanInterfaceMode.%X18 AND NOT #statBooleanInterfaceModeOld.%X18 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_15";
	    ELSIF #tempBooleanInterfaceMode.%X19 AND NOT #statBooleanInterfaceModeOld.%X19 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_16";
	    ELSIF #tempBooleanInterfaceMode.%X20 AND NOT #statBooleanInterfaceModeOld.%X20 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_17";
	    ELSIF #tempBooleanInterfaceMode.%X21 AND NOT #statBooleanInterfaceModeOld.%X21 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_18";
	    ELSIF #tempBooleanInterfaceMode.%X22 AND NOT #statBooleanInterfaceModeOld.%X22 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_19";
	    ELSIF #tempBooleanInterfaceMode.%X23 AND NOT #statBooleanInterfaceModeOld.%X23 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_20";
	    ELSIF #tempBooleanInterfaceMode.%X24 AND NOT #statBooleanInterfaceModeOld.%X24 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_21";
	    ELSIF #tempBooleanInterfaceMode.%X25 AND NOT #statBooleanInterfaceModeOld.%X25 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_22";
	    ELSIF #tempBooleanInterfaceMode.%X26 AND NOT #statBooleanInterfaceModeOld.%X26 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_23";
	    ELSIF #tempBooleanInterfaceMode.%X27 AND NOT #statBooleanInterfaceModeOld.%X27 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_24";
	    ELSIF #tempBooleanInterfaceMode.%X28 AND NOT #statBooleanInterfaceModeOld.%X28 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_25";
	    ELSIF #tempBooleanInterfaceMode.%X29 AND NOT #statBooleanInterfaceModeOld.%X29 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_26";
	    ELSIF #tempBooleanInterfaceMode.%X30 AND NOT #statBooleanInterfaceModeOld.%X30 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_27";
	    ELSIF #tempBooleanInterfaceMode.%X31 AND NOT #statBooleanInterfaceModeOld.%X31 THEN
	      #statUnitMode := "LPMLV30_MODE_USER_28";
	    ELSIF    #tempBooleanInterfaceMode.%X1  AND NOT #statBooleanInterfaceModeOld.%X1  THEN
	      #statUnitMode := "LPMLV30_MODE_PRODUCTION";
	    END_IF;
	    #statBooleanInterfaceModeOld := #tempBooleanInterfaceMode; // Save values for edge detection
	
	    // Evaluate CntrlCmd in boolean interface; priority descending: abort, stop, other commands
	    #statCmdChangeRequest    := TRUE; // Change request static TRUE
	    #tempBooleanInterfaceCmd := 0;
	
	    #tempBooleanInterfaceCmd.%X1  := #ResetCmdRequest;
	    #tempBooleanInterfaceCmd.%X2  := #StartCmdRequest;
	    #tempBooleanInterfaceCmd.%X4  := #HoldCmdRequest;
	    #tempBooleanInterfaceCmd.%X5  := #UnholdCmdRequest;
	    #tempBooleanInterfaceCmd.%X6  := #SuspendCmdRequest;
	    #tempBooleanInterfaceCmd.%X7  := #UnsuspendCmdRequest;
	    #tempBooleanInterfaceCmd.%X9  := #ClearCmdRequest;
	    #tempBooleanInterfaceCmd.%X10 := #CompleteCmdRequest; // Remember, complete command is not specified in the OMAC standard
	    
	    IF #AbortCmdRequest THEN
	      #tempCntrlCmd := "LPMLV30_CMD_ABORT";
	    ELSIF #StopCmdRequest THEN
	      #tempCntrlCmd := "LPMLV30_CMD_STOP";
	    ELSE
	      #tempCntrlCmd := "LPMLV30_CMD_UNDEFINED";
	
	      // Selection indicator: Rising edge at input, Priority (in case of multiple selection): complete, reset, start, hold, unhold, suspend, unsuspend, clear
	      IF    #tempBooleanInterfaceCmd.%X10 AND NOT #statBooleanInterfaceCmdOld.%X10 THEN
	        #tempCntrlCmd := "LPMLV30_CMD_COMPLETE";
	      ELSIF #tempBooleanInterfaceCmd.%X1  AND NOT #statBooleanInterfaceCmdOld.%X1  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_RESET";
	      ELSIF #tempBooleanInterfaceCmd.%X2  AND NOT #statBooleanInterfaceCmdOld.%X2  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_START";
	      ELSIF #tempBooleanInterfaceCmd.%X4  AND NOT #statBooleanInterfaceCmdOld.%X4  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_HOLD";
	      ELSIF #tempBooleanInterfaceCmd.%X5  AND NOT #statBooleanInterfaceCmdOld.%X5  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_UNHOLD";
	      ELSIF #tempBooleanInterfaceCmd.%X6  AND NOT #statBooleanInterfaceCmdOld.%X6  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_SUSPEND";
	      ELSIF #tempBooleanInterfaceCmd.%X7  AND NOT #statBooleanInterfaceCmdOld.%X7  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_UNSUSPEND";
	      ELSIF #tempBooleanInterfaceCmd.%X9  AND NOT #statBooleanInterfaceCmdOld.%X9  THEN
	        #tempCntrlCmd := "LPMLV30_CMD_CLEAR";
	      END_IF;
	    END_IF; // End: abort or stop cmd
	
	    #statBooleanInterfaceCmdOld := #tempBooleanInterfaceCmd; // Save values for edge detection
	  END_IF; // End: boolean interface
	END_IF; // End: As from second cycle
	// End: Evaluation of input parameters -> UnitMode, CntrlCmd
	
	//--------------------------------------------------------------------------------------------------
	// Unit mode manager
	//--------------------------------------------------------------------------------------------------
	IF NOT #statFirstCycle THEN // As from second cycle
	  //------------------------------------------------
	  //Message handling for mode manager: head part
	  //------------------------------------------------
	  IF #statUnitModeChangeRequest AND #statUnitMode <> #statUnitModeOld AND #statUnitMode <> "LPMLV30_MODE_INVALID" THEN
	    #tempDiagnosticsBufferIndex := #tempDiagnosticsBufferIndex + 1; // Next buffer index
	    IF #tempDiagnosticsBufferIndex > "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	      #tempDiagnosticsBufferIndex := 0;
	    END_IF;
	    // Check for defined unit modes
	    #tempRetVal := RD_SYS_T(#diagnostics.buffer[#tempDiagnosticsBufferIndex].timestamp);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitModeCurrent := DINT_TO_BYTE(#UnitModeCurrent);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].StateCurrent    := DINT_TO_BYTE(#StateCurrent);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitMode := DINT_TO_BYTE(#statUnitMode);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].CntrlCmd := DINT_TO_BYTE(#tempCntrlCmd);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].SC := #SC;
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_NO_MESSAGE;
	    
	    IF #statUnitMode < "LPMLV30_MODE_INVALID" OR #statUnitMode > "LPMLV30_MODE_USER_28" THEN
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_MODE_NOT_DEFINED;
	    ELSIF #statUnitMode = #statUnitModeCurrentInternal THEN
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_MODE_ALREADY_ACTIVE;
	    END_IF;
	  END_IF; // End: message handling for mode manager: head part
	END_IF; // End: As from second cycle
	
	//------------------------------------------------
	// Unit mode machine
	//------------------------------------------------
	// Check if unit mode has to be changed
	IF (#statUnitModeChangeRequest AND
	  #statUnitMode <> #statUnitModeCurrentInternal AND
	  #statUnitMode <> #statUnitModeOld AND
	  #statUnitMode > "LPMLV30_MODE_INVALID" AND
	  #statUnitMode <= "LPMLV30_MODE_USER_28"
	  ) OR
	  #statFirstCycle
	THEN
	  // Check if state is available
	  IF #statStateInternal = "LPMLV30_STATE_EXECUTE" OR //  Every state but not in execute
	    #statStateInternal <> #StateRequested // Means to be in wait state or target state             
	  THEN
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_MODE_TRANSITION_NOT_ALLOWED;
	  ELSE
	    IF #statConfiguration.disabledUnitModes[#statUnitMode] = FALSE THEN
	      // State in target unit mode available
	      IF ((NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X17 = FALSE) AND (#statStateInternal = "LPMLV30_STATE_COMPLETE")) OR
	        ((NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X11 = FALSE) AND (#statStateInternal = "LPMLV30_STATE_HELD")) OR
	        ((NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X5 = FALSE) AND (#statStateInternal = "LPMLV30_STATE_SUSPENDED"))
	      THEN
	        #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_MODE_TRANSITION_NOT_ALLOWED;
	      ELSE
	        // Set outputs
	        #UnitModeChangeInProcess := TRUE;
	        #UnitModeRequested := #statUnitMode;
	        // Set internal variable
	        #statUnitModeCurrentInternal := #statUnitMode;
	
	        // Read current configuration for state
	        #statStatesInCurrentMode.clearing := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X1;
	        #statStatesInCurrentMode.stopped := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X2;
	        #statStatesInCurrentMode.starting := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X3;
	        #statStatesInCurrentMode.idle := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X4;
	        #statStatesInCurrentMode.suspended := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X5;
	        #statStatesInCurrentMode.execute := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X6;
	        #statStatesInCurrentMode.stopping := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X7;
	        #statStatesInCurrentMode.aborting := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X8;
	        #statStatesInCurrentMode.aborted := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X9;
	        #statStatesInCurrentMode.holding := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X10;
	        #statStatesInCurrentMode.held := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X11;
	        #statStatesInCurrentMode.unholding := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X12;
	        #statStatesInCurrentMode.suspending := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X13;
	        #statStatesInCurrentMode.unsuspending := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X14;
	        #statStatesInCurrentMode.resetting := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X15;
	        #statStatesInCurrentMode.completing := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X16;
	        #statStatesInCurrentMode.complete := NOT #statConfiguration.disabledStatesInUnitModes[#statUnitMode].%X17;
	      END_IF; // End: state in target unit mode available
	    ELSE
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_REQ_MODE_NOT_CONFIGURED;
	    END_IF;
	  END_IF;
	
	  // Set the minimum required states for every unit mode
	  IF NOT #statStatesInCurrentMode.stopped OR
	    NOT #statStatesInCurrentMode.idle OR
	    NOT #statStatesInCurrentMode.execute OR
	    NOT #statStatesInCurrentMode.aborted OR
	    NOT #statStatesInCurrentMode.resetting OR
	    NOT #statStatesInCurrentMode.starting OR
	    NOT #statStatesInCurrentMode.stopping OR
	    NOT #statStatesInCurrentMode.clearing OR
	    NOT #statStatesInCurrentMode.aborting OR
	    (NOT #statStatesInCurrentMode.complete AND #statStatesInCurrentMode.completing) OR
	    (NOT #statStatesInCurrentMode.suspended AND (#statStatesInCurrentMode.suspending OR #statStatesInCurrentMode.unsuspending)) OR
	    (NOT #statStatesInCurrentMode.held AND (#statStatesInCurrentMode.holding OR #statStatesInCurrentMode.unholding))
	  THEN
	    #statStatesInCurrentMode.stopped := TRUE;
	    #statStatesInCurrentMode.idle := TRUE;
	    #statStatesInCurrentMode.execute := TRUE;
	    #statStatesInCurrentMode.aborted := TRUE;
	    
	    #statStatesInCurrentMode.resetting := TRUE;
	    #statStatesInCurrentMode.starting := TRUE;
	    #statStatesInCurrentMode.aborting := TRUE;
	    #statStatesInCurrentMode.stopping := TRUE;
	    #statStatesInCurrentMode.clearing := TRUE;
	    
	    // Held
	    IF NOT #statStatesInCurrentMode.held
	      AND (#statStatesInCurrentMode.holding OR #statStatesInCurrentMode.unholding)
	    THEN
	      #statStatesInCurrentMode.held := TRUE;
	      #statStatesInCurrentMode.holding := TRUE;
	      #statStatesInCurrentMode.unholding := TRUE;
	    END_IF;
	    // Suspended
	    IF NOT #statStatesInCurrentMode.suspended
	      AND (#statStatesInCurrentMode.suspending OR #statStatesInCurrentMode.unsuspending)
	    THEN
	      #statStatesInCurrentMode.suspended := TRUE;
	      #statStatesInCurrentMode.suspending := TRUE;
	      #statStatesInCurrentMode.unsuspending := TRUE;
	    END_IF;
	    // Complete
	    IF NOT #statStatesInCurrentMode.complete
	      AND #statStatesInCurrentMode.completing
	    THEN
	      #statStatesInCurrentMode.complete := TRUE;
	      #statStatesInCurrentMode.completing := TRUE;
	    END_IF;
	    
	    #tempDiagnosticsBufferIndex := #tempDiagnosticsBufferIndex + 1; // Next buffer index
	    IF #tempDiagnosticsBufferIndex > "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	      #tempDiagnosticsBufferIndex := 0;
	    END_IF;
	    
	    // Write diagnostics
	    #tempRetVal := RD_SYS_T(#diagnostics.buffer[#tempDiagnosticsBufferIndex].timestamp);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitModeCurrent := DINT_TO_BYTE(#UnitModeCurrent);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].StateCurrent    := DINT_TO_BYTE(#StateCurrent);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitMode := DINT_TO_BYTE(#statUnitMode);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].CntrlCmd := DINT_TO_BYTE(#tempCntrlCmd);
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].SC := #SC;
	    #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_STATE_CONFIG_FORCED;
	  END_IF; // End: set the minimum required states for every unit mode
	  
	  #UnitModeCurrent := #statUnitModeCurrentInternal; // Write current unit mode on output
	  
	  // Write correct state configuration of current mode
	  #StatesDisabled.%X1 := NOT #statStatesInCurrentMode.clearing;
	  #StatesDisabled.%X2 := NOT #statStatesInCurrentMode.stopped;
	  #StatesDisabled.%X3 := NOT #statStatesInCurrentMode.starting;
	  #StatesDisabled.%X4 := NOT #statStatesInCurrentMode.idle;
	  #StatesDisabled.%X5 := NOT #statStatesInCurrentMode.suspended;
	  #StatesDisabled.%X6 := NOT #statStatesInCurrentMode.execute;
	  #StatesDisabled.%X7 := NOT #statStatesInCurrentMode.stopping;
	  #StatesDisabled.%X8 := NOT #statStatesInCurrentMode.aborting;
	  #StatesDisabled.%X9 := NOT #statStatesInCurrentMode.aborted;
	  #StatesDisabled.%X10 := NOT #statStatesInCurrentMode.holding;
	  #StatesDisabled.%X11 := NOT #statStatesInCurrentMode.held;
	  #StatesDisabled.%X12 := NOT #statStatesInCurrentMode.unholding;
	  #StatesDisabled.%X13 := NOT #statStatesInCurrentMode.suspending;
	  #StatesDisabled.%X14 := NOT #statStatesInCurrentMode.unsuspending;
	  #StatesDisabled.%X15 := NOT #statStatesInCurrentMode.resetting;
	  #StatesDisabled.%X16 := NOT #statStatesInCurrentMode.completing;
	  #StatesDisabled.%X17 := NOT #statStatesInCurrentMode.complete;
	  
	  //-----------------------------------------------
	  // Message handling for mode manager: foot part
	  //-----------------------------------------------
	  IF NOT #statFirstCycle THEN
	    IF #diagnostics.buffer[#tempDiagnosticsBufferIndex].message = #MSG_NO_MESSAGE THEN // ELSE: Unit mode wasn´t changed successfully
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_MODE_CHANGED_SUCCESSFULLY;
	    END_IF;
	  END_IF;
	ELSE
	  #UnitModeChangeInProcess := FALSE; // No unit mode change
	END_IF;// End: check if unit mode has to be changed
	// End: Unit mode manager
	
	//--------------------------------------------------------------------------------------------------
	// State manager
	//--------------------------------------------------------------------------------------------------
	IF NOT #statFirstCycle THEN // As from second cycle
	  IF #SC AND NOT #statSCOld THEN // Detect a rising edge at state complete signal
	    #tempSCInternal := TRUE;
	  ELSE
	    #tempSCInternal := FALSE;
	  END_IF;
	  #statSCOld := #SC; // End: Detect a rising edge at state complete signal
	
	  //---------------------------------------------------------------------
	  // Message handling for state manager: head part 
	  //---------------------------------------------------------------------
	  IF #tempSCInternal THEN // Check if rising edge of SC was detected
	    #tempDiagnosticsBufferIndex := #tempDiagnosticsBufferIndex + 1; // Next buffer index
	    IF #tempDiagnosticsBufferIndex > "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	      #tempDiagnosticsBufferIndex := 0;
	    END_IF;
	    #tempDiagnosticsBufferIndexSC := #tempDiagnosticsBufferIndex;
	
	    // Check current state to use SC
	    IF #statStateInternal = "LPMLV30_STATE_CLEARING"    OR
	      #statStateInternal = "LPMLV30_STATE_STARTING"     OR
	      #statStateInternal = "LPMLV30_STATE_STOPPING"     OR
	      #statStateInternal = "LPMLV30_STATE_ABORTING"     OR
	      #statStateInternal = "LPMLV30_STATE_HOLDING"      OR
	      #statStateInternal = "LPMLV30_STATE_UNHOLDING"    OR
	      #statStateInternal = "LPMLV30_STATE_SUSPENDING"   OR
	      #statStateInternal = "LPMLV30_STATE_UNSUSPENDING" OR
	      #statStateInternal = "LPMLV30_STATE_RESETTING"    OR
	      #statStateInternal = "LPMLV30_STATE_COMPLETING"   OR
	      #statStateInternal = "LPMLV30_STATE_EXECUTE"
	    THEN // Write diagnostics     
	      #tempRetVal := RD_SYS_T(#diagnostics.buffer[#tempDiagnosticsBufferIndex].timestamp);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitModeCurrent := DINT_TO_BYTE(#UnitModeCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].StateCurrent    := DINT_TO_BYTE(#StateCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitMode := DINT_TO_BYTE(#statUnitMode);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].CntrlCmd := DINT_TO_BYTE(#tempCntrlCmd);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].SC := #SC;
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_NO_MESSAGE;
	    ELSE // Write diagnostics
	      #tempRetVal := RD_SYS_T(#diagnostics.buffer[#tempDiagnosticsBufferIndex].timestamp);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitModeCurrent := DINT_TO_BYTE(#UnitModeCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].StateCurrent    := DINT_TO_BYTE(#StateCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitMode := DINT_TO_BYTE(#statUnitMode);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].CntrlCmd := DINT_TO_BYTE(#tempCntrlCmd);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].SC := #SC;
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_SC_NOT_ALLOWED;
	    END_IF; // End: Check current state to use SC
	  END_IF;
	  
	  // Check if defined control command was sent correctly
	  IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN
	    IF #tempCntrlCmd = "LPMLV30_CMD_RESET"     OR
	       #tempCntrlCmd = "LPMLV30_CMD_START"     OR
	       #tempCntrlCmd = "LPMLV30_CMD_STOP"      OR
	       #tempCntrlCmd = "LPMLV30_CMD_HOLD"      OR
	       #tempCntrlCmd = "LPMLV30_CMD_UNHOLD"    OR
	       #tempCntrlCmd = "LPMLV30_CMD_SUSPEND"   OR
	       #tempCntrlCmd = "LPMLV30_CMD_UNSUSPEND" OR
	       #tempCntrlCmd = "LPMLV30_CMD_ABORT"     OR
	       #tempCntrlCmd = "LPMLV30_CMD_CLEAR"     OR
	       #tempCntrlCmd = "LPMLV30_CMD_COMPLETE" // Info: Complete command not in the OMAC standard
	    THEN
	      #tempDiagnosticsBufferIndex := #tempDiagnosticsBufferIndex + 1; // Next buffer index
	      IF #tempDiagnosticsBufferIndex > "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	        #tempDiagnosticsBufferIndex := 0;
	      END_IF;
	      #tempDiagnosticsBufferIndexCmd := #tempDiagnosticsBufferIndex;
	
	      // Write diagnostics
	      #tempRetVal := RD_SYS_T(#diagnostics.buffer[#tempDiagnosticsBufferIndex].timestamp);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitModeCurrent := DINT_TO_BYTE(#UnitModeCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].StateCurrent    := DINT_TO_BYTE(#StateCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitMode := DINT_TO_BYTE(#statUnitMode);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].CntrlCmd := DINT_TO_BYTE(#tempCntrlCmd);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].SC := #SC;
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_NO_MESSAGE;
	      // Write message if CntrlCmd is not allowed
	      IF ((#statStateInternal = "LPMLV30_STATE_CLEARING" OR
	        #statStateInternal = "LPMLV30_STATE_STARTING" OR
	        #statStateInternal = "LPMLV30_STATE_STOPPING" OR
	        #statStateInternal = "LPMLV30_STATE_ABORTING" OR
	        #statStateInternal = "LPMLV30_STATE_HOLDING" OR
	        #statStateInternal = "LPMLV30_STATE_UNHOLDING" OR
	        #statStateInternal = "LPMLV30_STATE_SUSPENDING" OR
	        #statStateInternal = "LPMLV30_STATE_UNSUSPENDING" OR
	        #statStateInternal = "LPMLV30_STATE_RESETTING" OR
	        #statStateInternal = "LPMLV30_STATE_COMPLETING") AND
	        NOT (#tempCntrlCmd = "LPMLV30_CMD_ABORT") AND NOT (#tempCntrlCmd = "LPMLV30_CMD_STOP")) OR
	        (#statStateInternal = "LPMLV30_STATE_ABORTED" AND (#tempCntrlCmd = "LPMLV30_CMD_ABORT"))
	      THEN
	        #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_CMD_NOT_ALLOWED;
	      END_IF;
	    ELSE
	      // Not defined control command was sent
	      #tempDiagnosticsBufferIndex := #tempDiagnosticsBufferIndex + 1; // Next buffer index
	      IF #tempDiagnosticsBufferIndex > "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	        #tempDiagnosticsBufferIndex := 0;
	      END_IF;
	      #tempDiagnosticsBufferIndexCmd := #tempDiagnosticsBufferIndex;
	
	      // Write diagnostics
	      #tempRetVal := RD_SYS_T(#diagnostics.buffer[#tempDiagnosticsBufferIndex].timestamp);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitModeCurrent := DINT_TO_BYTE(#UnitModeCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].StateCurrent    := DINT_TO_BYTE(#StateCurrent);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].UnitMode := DINT_TO_BYTE(#statUnitMode);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].CntrlCmd := DINT_TO_BYTE(#tempCntrlCmd);
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].SC := #SC;
	      #diagnostics.buffer[#tempDiagnosticsBufferIndex].message := #MSG_CMD_NOT_DEFINED;
	    END_IF;
	  END_IF; // End: message handling for state manager: head part 
	  
	  //---------------------------------------------------------------------
	  // State machine
	  //---------------------------------------------------------------------
	  IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd = "LPMLV30_CMD_ABORT" AND // Check if abort command was sent correctly    
	    #statStateInternal <> "LPMLV30_STATE_ABORTED" AND
	    #statStateInternal <> "LPMLV30_STATE_ABORTING"
	  THEN
	    // Abort command was sent correctly
	    #StateChangeInProcess := TRUE;
	    #StateRequested := "LPMLV30_STATE_ABORTED";
	    // Select next state
	    IF #statStatesInCurrentMode.aborting THEN
	      #statStateInternal := "LPMLV30_STATE_ABORTING";
	    ELSE
	      #statStateInternal := "LPMLV30_STATE_ABORTED";
	    END_IF;
	    
	  ELSIF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd = "LPMLV30_CMD_STOP" AND // Check if correct stop command was sent
	    #statStateInternal <> "LPMLV30_STATE_ABORTED"  AND
	    #statStateInternal <> "LPMLV30_STATE_ABORTING" AND
	    #statStateInternal <> "LPMLV30_STATE_CLEARING" AND
	    #statStateInternal <> "LPMLV30_STATE_STOPPING" AND
	    #statStateInternal <> "LPMLV30_STATE_STOPPED"
	  THEN
	    // Stop command was sent correctly
	    #StateChangeInProcess := TRUE;
	    #StateRequested := "LPMLV30_STATE_STOPPED";
	    // Select next state
	    IF #statStatesInCurrentMode.stopping THEN
	      #statStateInternal := "LPMLV30_STATE_STOPPING";
	    ELSE
	      #statStateInternal := "LPMLV30_STATE_STOPPED";
	    END_IF;
	    
	  ELSE // Internal state machine
	    CASE #statStateInternal OF
	      "LPMLV30_STATE_EXECUTE":
	        #StateChangeInProcess := FALSE;
	        // Check if state is completed
	        IF #tempSCInternal AND #statStatesInCurrentMode.completing THEN // ELSE: Wait for SC (state complete)
	          #StateChangeInProcess := TRUE;
	          #StateRequested    := "LPMLV30_STATE_COMPLETE";
	          #statStateInternal := "LPMLV30_STATE_COMPLETING";
	        ELSIF #tempSCInternal AND #statStatesInCurrentMode.complete THEN
	          #StateChangeInProcess := TRUE;
	          #StateRequested    := "LPMLV30_STATE_COMPLETE";
	          #statStateInternal := "LPMLV30_STATE_COMPLETE";
	        ELSIF #tempSCInternal AND NOT #statStatesInCurrentMode.completing AND NOT #statStatesInCurrentMode.complete THEN
	          #diagnostics.buffer[#tempDiagnosticsBufferIndexSC].message := #MSG_SC_NOT_ALLOWED;
	        END_IF;
	
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" AND
	          NOT (#tempSCInternal AND (#statStatesInCurrentMode.completing OR #statStatesInCurrentMode.complete))
	        THEN // Check if state change is requested
	          CASE #tempCntrlCmd OF // Check control command
	            "LPMLV30_CMD_COMPLETE": // Remember, the Complete command is not specified in the OMAC standard
	              // Check if valid state for command is in use by current unit mode
	              IF #statStatesInCurrentMode.completing THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_COMPLETE";
	                #statStateInternal := "LPMLV30_STATE_COMPLETING";
	              ELSIF #statStatesInCurrentMode.complete THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_COMPLETE";
	                #statStateInternal := "LPMLV30_STATE_COMPLETE";
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	              
	            "LPMLV30_CMD_RESET":
	              IF NOT #statStatesInCurrentMode.completing AND NOT #statStatesInCurrentMode.complete THEN
	                // Check if valid state for command is in use by current unit mode
	                IF #statStatesInCurrentMode.resetting THEN
	                  #StateChangeInProcess := TRUE;
	                  #StateRequested    := "LPMLV30_STATE_IDLE";
	                  #statStateInternal := "LPMLV30_STATE_RESETTING";
	                ELSIF #statStatesInCurrentMode.idle THEN
	                  #StateChangeInProcess := TRUE;
	                  #StateRequested    := "LPMLV30_STATE_IDLE";
	                  #statStateInternal := "LPMLV30_STATE_IDLE";
	                ELSE
	                  #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	                END_IF;
	              END_IF;
	              
	            "LPMLV30_CMD_HOLD":
	              // Check if valid state for command is in use by current unit mode
	              IF #statStatesInCurrentMode.holding THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_HELD";
	                #statStateInternal := "LPMLV30_STATE_HOLDING";
	              ELSIF #statStatesInCurrentMode.held THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_HELD";
	                #statStateInternal := "LPMLV30_STATE_HELD";
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	              
	            "LPMLV30_CMD_SUSPEND":
	              // Check if valid state for command is in use by current unit mode
	              IF #statStatesInCurrentMode.suspending THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_SUSPENDED";
	                #statStateInternal := "LPMLV30_STATE_SUSPENDING";
	              ELSIF #statStatesInCurrentMode.suspended THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_SUSPENDED";
	                #statStateInternal := "LPMLV30_STATE_SUSPENDED";
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	        
	      "LPMLV30_STATE_COMPLETING":
	        // Check if state is completed
	        IF #tempSCInternal AND #statStatesInCurrentMode.complete THEN
	          #statStateInternal := "LPMLV30_STATE_COMPLETE";
	        ELSIF #tempSCInternal AND NOT #statStatesInCurrentMode.complete THEN
	          #diagnostics.buffer[#tempDiagnosticsBufferIndexSC].message := #MSG_SC_NOT_ALLOWED;
	        END_IF;
	        
	      "LPMLV30_STATE_COMPLETE":
	        #StateChangeInProcess := FALSE;
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN // Check if state change is requested
	          CASE #tempCntrlCmd OF // Check control command
	            "LPMLV30_CMD_RESET":
	              // Check if valid state for command is in use by current unit mode
	              IF #statStatesInCurrentMode.resetting THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_IDLE";
	                #statStateInternal := "LPMLV30_STATE_RESETTING";
	              ELSIF #statStatesInCurrentMode.idle THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_IDLE";
	                #statStateInternal := "LPMLV30_STATE_IDLE";
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	              
	            "LPMLV30_CMD_START":
	              // Check if valid state for command is in use by current unit mode
	              IF NOT #statStatesInCurrentMode.resetting AND NOT #statStatesInCurrentMode.idle THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested := "LPMLV30_STATE_EXECUTE";
	                // Check if valid state for command is in use by current unit mode
	                IF #statStatesInCurrentMode.starting THEN
	                  #statStateInternal := "LPMLV30_STATE_STARTING";
	                ELSE
	                  #statStateInternal := "LPMLV30_STATE_EXECUTE";
	                END_IF;
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	        
	      "LPMLV30_STATE_RESETTING":
	        // Check if state is completed
	        // No message handling needed -> Idle is minimum required state
	        IF #tempSCInternal THEN // ELSE: Wait for state complete signal
	          #statStateInternal := "LPMLV30_STATE_IDLE";
	        END_IF;
	        
	      "LPMLV30_STATE_IDLE":
	        #StateChangeInProcess := FALSE;
	        //  No message handling needed -> Execute is minimum required state
	        //  Check if valid command is sent
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN // Check if state change is requested      
	          CASE #tempCntrlCmd OF // Check control command
	            "LPMLV30_CMD_START":
	              #StateChangeInProcess := TRUE;
	              #StateRequested := "LPMLV30_STATE_EXECUTE";
	              // Check if valid state for command is in use by current mode
	              IF #statStatesInCurrentMode.starting THEN
	                #statStateInternal := "LPMLV30_STATE_STARTING";
	              ELSE
	                #statStateInternal := "LPMLV30_STATE_EXECUTE";
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	        
	      "LPMLV30_STATE_STARTING",
	      "LPMLV30_STATE_UNHOLDING",
	      "LPMLV30_STATE_UNSUSPENDING":
	        // Check if state is completed
	        IF #tempSCInternal THEN // ELSE: Wait for state complete signal
	          #statStateInternal := "LPMLV30_STATE_EXECUTE";
	        END_IF;
	        
	      "LPMLV30_STATE_HOLDING":
	        // Check if state is completed
	        IF #tempSCInternal AND #statStatesInCurrentMode.held THEN // ELSE: Wait for state complete signal
	          #statStateInternal := "LPMLV30_STATE_HELD";
	        ELSIF #tempSCInternal AND NOT #statStatesInCurrentMode.held THEN
	          #diagnostics.buffer[#tempDiagnosticsBufferIndexSC].message := #MSG_SC_NOT_ALLOWED;
	        END_IF;
	        
	      "LPMLV30_STATE_HELD":
	        #StateChangeInProcess := FALSE;
	        //  Check if valid command is sent
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN // Check if state change is requested
	          CASE #tempCntrlCmd OF // Check control command
	            "LPMLV30_CMD_UNHOLD":
	              #StateChangeInProcess := TRUE;
	              #StateRequested := "LPMLV30_STATE_EXECUTE";
	              // Check if valid state for command is in use by current mode
	              IF #statStatesInCurrentMode.unholding THEN
	                #statStateInternal := "LPMLV30_STATE_UNHOLDING";
	              ELSE
	                #statStateInternal := "LPMLV30_STATE_EXECUTE";
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	
	      "LPMLV30_STATE_SUSPENDING":
	        // Check if state is completed
	        IF #tempSCInternal AND #statStatesInCurrentMode.suspended THEN // ELSE: Wait for state complete signal
	          #statStateInternal := "LPMLV30_STATE_SUSPENDED";
	        ELSIF #tempSCInternal AND NOT #statStatesInCurrentMode.suspended THEN
	          #diagnostics.buffer[#tempDiagnosticsBufferIndexSC].message := #MSG_SC_NOT_ALLOWED;
	        END_IF;
	        
	      "LPMLV30_STATE_SUSPENDED":
	        #StateChangeInProcess := FALSE;
	        //  Check if valid command is sent
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN // Check if state change is requested
	          CASE #tempCntrlCmd OF // Check control command
	            "LPMLV30_CMD_UNSUSPEND":
	              #StateChangeInProcess := TRUE;
	              #StateRequested := "LPMLV30_STATE_EXECUTE";
	              // Check if valid state for command is in use by current mode
	              IF #statStatesInCurrentMode.unsuspending THEN
	                #statStateInternal := "LPMLV30_STATE_UNSUSPENDING";
	              ELSE
	                #statStateInternal := "LPMLV30_STATE_EXECUTE";
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	        
	      "LPMLV30_STATE_ABORTING":
	        // Check if state is completed
	        IF #tempSCInternal THEN // ELSE: Wait for state complete signal
	          #statStateInternal := "LPMLV30_STATE_ABORTED";
	        END_IF;
	
	      "LPMLV30_STATE_ABORTED":
	        #StateChangeInProcess := FALSE;
	        //  Check if valid command is sent
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN // Check if state change is requested
	          CASE #tempCntrlCmd OF // Check control command
	            "LPMLV30_CMD_CLEAR":
	              #StateChangeInProcess := TRUE;
	              #StateRequested := "LPMLV30_STATE_STOPPED";
	              // Check if valid state for command is in use by current mode
	              IF #statStatesInCurrentMode.clearing THEN
	                #statStateInternal := "LPMLV30_STATE_CLEARING";
	              ELSE
	                #statStateInternal := "LPMLV30_STATE_STOPPED";
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	
	      "LPMLV30_STATE_CLEARING",
	      "LPMLV30_STATE_STOPPING":
	        // Check if state is completed
	        IF #tempSCInternal THEN // ELSE: Wait for state complete signal
	          #statStateInternal := "LPMLV30_STATE_STOPPED";
	        END_IF;
	        
	      "LPMLV30_STATE_STOPPED":
	        #StateChangeInProcess := FALSE;
	        IF #statCmdChangeRequest AND #tempCntrlCmd <> #statCntrlCmdOld AND #tempCntrlCmd <> "LPMLV30_CMD_UNDEFINED" THEN // Check if state change is requested
	          // Check if valid command is sent
	          CASE #tempCntrlCmd OF
	            "LPMLV30_CMD_RESET":
	              // Check if valid state for command is in use by current unit mode
	              IF #statStatesInCurrentMode.resetting THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_IDLE";
	                #statStateInternal := "LPMLV30_STATE_RESETTING";
	              ELSIF #statStatesInCurrentMode.idle THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested    := "LPMLV30_STATE_IDLE";
	                #statStateInternal := "LPMLV30_STATE_IDLE";
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	              
	            "LPMLV30_CMD_START":
	              IF NOT #statStatesInCurrentMode.resetting AND NOT #statStatesInCurrentMode.idle THEN
	                #StateChangeInProcess := TRUE;
	                #StateRequested := "LPMLV30_STATE_EXECUTE";
	                // Check if valid state for command is in use by current mode
	                IF #statStatesInCurrentMode.starting THEN
	                  #statStateInternal := "LPMLV30_STATE_STARTING";
	                ELSE
	                  #statStateInternal := "LPMLV30_STATE_EXECUTE";
	                END_IF;
	              ELSE
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	            ELSE
	              IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN // ELSE: Message was already written in head part of message handling
	                #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_CMD_NOT_ALLOWED;
	              END_IF;
	          END_CASE;
	        END_IF;
	        
	      "LPMLV30_STATE_UNDEFINED":
	        #StateChangeInProcess := FALSE;
	        #StateRequested    := "LPMLV30_STATE_STOPPED";
	        #statStateInternal := "LPMLV30_STATE_STOPPED";
	      ELSE
	        ; // Undefined state
	    END_CASE;
	  END_IF; // End: state machine
	
	  //-------------------------------------------------
	  // Message handling for state manager: foot part
	  //-------------------------------------------------
	  IF #statStateInternal <> #statStateCurrentOld THEN // ELSE: States were not changed
	    IF #tempDiagnosticsBufferIndexCmd >= 0 AND #tempDiagnosticsBufferIndexCmd <= "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	      IF #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message = #MSG_NO_MESSAGE THEN
	        #diagnostics.buffer[#tempDiagnosticsBufferIndexCmd].message := #MSG_STATE_CHANGED_SUCCESSFULLY;
	      END_IF;
	    END_IF;
	    IF #tempDiagnosticsBufferIndexSC >= 0 AND #tempDiagnosticsBufferIndexSC <= "LPMLV30_DIAG_BUFFER_UPPER_LIM" THEN
	      IF #diagnostics.buffer[#tempDiagnosticsBufferIndexSC].message = #MSG_NO_MESSAGE THEN
	        #diagnostics.buffer[#tempDiagnosticsBufferIndexSC].message := #MSG_STATE_CHANGED_SUCCESSFULLY;
	      END_IF;
	    END_IF;
	  END_IF; // End: message handling for state manager: foot part
	END_IF; // End: As from second cycle
	// End: State manager
	
	//--------------------------------------------------------------------------------------------------
	// Write outputs including boolean interface outputs 
	//--------------------------------------------------------------------------------------------------
	IF #statUnitModeCurrentInternal <> #statUnitModeCurrentInternalOld THEN // Check if new unit mode is selected
	  #ProductionModeActive  := FALSE;
	  #MaintenanceModeActive := FALSE;
	  #ManualModeActive      := FALSE;
	  #UserMode01Active      := FALSE;
	  #UserMode02Active      := FALSE;
	  #UserMode03Active      := FALSE;
	  #UserMode04Active      := FALSE;
	  #UserMode05Active      := FALSE;
	  #UserMode06Active      := FALSE;
	  #UserMode07Active      := FALSE;
	  #UserMode08Active      := FALSE;
	  // #UserMode09Active := FALSE;
	  // #UserMode10Active := FALSE;
	  // #UserMode11Active := FALSE;
	  // #UserMode13Active := FALSE;
	  // #UserMode14Active := FALSE;
	  // #UserMode15Active := FALSE;
	  // #UserMode16Active := FALSE;
	  // #UserMode17Active := FALSE;
	  // #UserMode18Active := FALSE;
	  // #UserMode19Active := FALSE;
	  // #UserMode20Active := FALSE;
	  // #UserMode21Active := FALSE;
	  // #UserMode22Active := FALSE;
	  // #UserMode23Active := FALSE;
	  // #UserMode24Active := FALSE;
	  // #UserMode25Active := FALSE;
	  // #UserMode26Active := FALSE;
	  // #UserMode27Active := FALSE;
	  // #UserMode28Active := FALSE;
	
	  CASE #statUnitModeCurrentInternal OF // Set new bit for current unit mode
	    "LPMLV30_MODE_PRODUCTION":
	      #ProductionModeActive := TRUE;
	    "LPMLV30_MODE_MAINTENANCE":
	      #MaintenanceModeActive := TRUE;
	    "LPMLV30_MODE_MANUAL":
	      #ManualModeActive := TRUE;
	    "LPMLV30_MODE_USER_01":
	      #UserMode01Active := TRUE;
	    "LPMLV30_MODE_USER_02":
	      #UserMode02Active := TRUE;
	    "LPMLV30_MODE_USER_03":
	      #UserMode03Active := TRUE;
	    "LPMLV30_MODE_USER_04":
	      #UserMode04Active := TRUE;
	    "LPMLV30_MODE_USER_05":
	      #UserMode05Active := TRUE;
	    "LPMLV30_MODE_USER_06":
	      #UserMode06Active := TRUE;
	    "LPMLV30_MODE_USER_07":
	      #UserMode07Active := TRUE;
	    "LPMLV30_MODE_USER_08":
	      #UserMode08Active := TRUE;
	    // LPMLV30_MODE_USER_09:
	    //   #UserMode09Active := TRUE;
	    // LPMLV30_MODE_USER_10:
	    //   #UserMode10Active := TRUE;
	    // LPMLV30_MODE_USER_11:
	    //   #UserMode11Active := TRUE;
	    // LPMLV30_MODE_USER_12:
	    //   #UserMode12Active := TRUE;
	    // LPMLV30_MODE_USER_13:
	    //   #UserMode13Active := TRUE;
	    // LPMLV30_MODE_USER_14:
	    //   #UserMode14Active := TRUE;
	    // LPMLV30_MODE_USER_15:
	    //   #UserMode15Active := TRUE;
	    // LPMLV30_MODE_USER_16:
	    //   #UserMode16Active := TRUE;
	    // LPMLV30_MODE_USER_17:
	    //   #UserMode17Active := TRUE;
	    // LPMLV30_MODE_USER_18:
	    //   #UserMode18Active := TRUE;
	    // LPMLV30_MODE_USER_19:
	    //   #UserMode19Active := TRUE;
	    // LPMLV30_MODE_USER_20:
	    //   #UserMode20Active := TRUE;
	    // LPMLV30_MODE_USER_21:
	    //   #UserMode21Active := TRUE;
	    // LPMLV30_MODE_USER_22:
	    //   #UserMode22Active := TRUE;
	    // LPMLV30_MODE_USER_23:
	    //   #UserMode23Active := TRUE;
	    // LPMLV30_MODE_USER_24:
	    //   #UserMode25Active := TRUE;
	    // LPMLV30_MODE_USER_25:
	    //   #UserMode25Active := TRUE;
	    // LPMLV30_MODE_USER_26:
	    //   #UserMode26Active := TRUE;
	    // LPMLV30_MODE_USER_27:
	    //   #UserMode27Active := TRUE;
	    // LPMLV30_MODE_USER_28:
	    //   #UserMode28Active := TRUE;
	    ELSE
	      ; // No bit is set
	  END_CASE;
	  
	  #statUnitModeCurrentInternalOld := #statUnitModeCurrentInternal;
	END_IF;
	
	IF #statStateInternal <> #statStateInternalOld THEN // Check if new state is selected 
	  #StateCurrent := #statStateInternal; // Set output
	  
	  // Set states of boolean interface out
	  // Delete old state  
	  #ClearingStateActive     := FALSE;
	  #StoppedStateActive      := FALSE;
	  #StartingStateActive     := FALSE;
	  #IdleStateActive         := FALSE;
	  #SuspendedStateActive    := FALSE;
	  #ExecuteStateActive      := FALSE;
	  #StoppingStateActive     := FALSE;
	  #AbortingStateActive     := FALSE;
	  #AbortedStateActive      := FALSE;
	  #HoldingStateActive      := FALSE;
	  #HeldStateActive         := FALSE;
	  #UnholdingStateActive    := FALSE;
	  #SuspendingStateActive   := FALSE;
	  #UnsuspendingStateActive := FALSE;
	  #ResettingStateActive    := FALSE;
	  #CompletingStateActive   := FALSE;
	  #CompleteStateActive     := FALSE;
	
	  // Set new state
	  CASE #statStateInternal OF
	    "LPMLV30_STATE_CLEARING":
	      #ClearingStateActive := TRUE;
	    "LPMLV30_STATE_STOPPED":
	      #StoppedStateActive := TRUE;
	    "LPMLV30_STATE_STARTING":
	      #StartingStateActive := TRUE;
	    "LPMLV30_STATE_IDLE":
	      #IdleStateActive := TRUE;
	    "LPMLV30_STATE_SUSPENDED":
	      #SuspendedStateActive := TRUE;
	    "LPMLV30_STATE_EXECUTE":
	      #ExecuteStateActive := TRUE;
	    "LPMLV30_STATE_STOPPING":
	      #StoppingStateActive := TRUE;
	    "LPMLV30_STATE_ABORTING":
	      #AbortingStateActive := TRUE;
	    "LPMLV30_STATE_ABORTED":
	      #AbortedStateActive := TRUE;
	    "LPMLV30_STATE_HOLDING":
	      #HoldingStateActive := TRUE;
	    "LPMLV30_STATE_HELD":
	      #HeldStateActive := TRUE;
	    "LPMLV30_STATE_UNHOLDING":
	      #UnholdingStateActive := TRUE;
	    "LPMLV30_STATE_SUSPENDING":
	      #SuspendingStateActive := TRUE;
	    "LPMLV30_STATE_UNSUSPENDING":
	      #UnsuspendingStateActive := TRUE;
	    "LPMLV30_STATE_RESETTING":
	      #ResettingStateActive := TRUE;
	    "LPMLV30_STATE_COMPLETING":
	      #CompletingStateActive := TRUE;
	    "LPMLV30_STATE_COMPLETE":
	      #CompleteStateActive := TRUE;
	    ELSE
	      ;
	  END_CASE; // End: Set new state
	  
	  #statStateInternalOld := #statStateInternal;
	END_IF;// End: Write boolean interface outputs
	
	#diagnostics.bufferIndex := #tempDiagnosticsBufferIndex; // Temporary variable is used during block execution -> Copy back/Set output
	IF #statFirstCycle THEN
	  #statFirstCycle := FALSE;
	END_IF;
	
	// Save values for edge detection
	IF #statUnitModeChangeRequest THEN
	  #statUnitModeOld := #statUnitMode;
	END_IF;
	IF #statCmdChangeRequest THEN
	  #statCntrlCmdOld := #tempCntrlCmd;
	END_IF;
	IF #statStateInternal <> #statStateCurrentOld THEN
	  #statStateCurrentOld := #statStateInternal;
	END_IF;
	
	//============================================================================================================
	// End of function block: LPMLV30_UnitModeStateManager
	//============================================================================================================
END_FUNCTION_BLOCK

